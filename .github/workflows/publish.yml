name: 🚀 Build and Publish to PyPI

on:
  # Trigger ONLY when release/* branches are merged to main
  push:
    branches:
      - main
  
  # Allow manual triggering for emergency releases
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to publish (optional - will use pyproject.toml if empty)'
        required: false
        type: string

# Set workflow-level permissions
permissions:
  contents: write       # For creating releases and accessing repository content
  actions: read         # For workflow context
  id-token: write       # For OIDC token access
  pull-requests: read   # For PR information access

jobs:
  # Check if this is a release branch merge
  check-release:
    name: 🔍 Check Release Branch
    runs-on: ubuntu-latest
    outputs:
      is-release: ${{ steps.check.outputs.is-release }}
      branch-name: ${{ steps.check.outputs.branch-name }}
      release-type: ${{ steps.check.outputs.release-type }}
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: 🔍 Check if release branch merge
      id: check
      run: |
        # Get the commit message to see if this was a merge from release/* or hotfix/*
        COMMIT_MSG=$(git log -1 --pretty=%B)
        echo "Commit message: $COMMIT_MSG"
        
        # Check if this is a merge commit from a release or hotfix branch
        if [[ $COMMIT_MSG =~ (from .*/(release|hotfix)/) ]] || [[ $COMMIT_MSG =~ "Merge branch '(release|hotfix)/" ]]; then
          echo "is-release=true" >> $GITHUB_OUTPUT
          # Extract branch name from commit message
          BRANCH_NAME=$(echo "$COMMIT_MSG" | grep -oE "(release|hotfix)/[^'\"]*" | head -1)
          echo "branch-name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          # Determine release type
          if [[ $BRANCH_NAME == release/* ]]; then
            echo "release-type=release" >> $GITHUB_OUTPUT
            echo "✅ Release branch merge detected: $BRANCH_NAME"
          elif [[ $BRANCH_NAME == hotfix/* ]]; then
            echo "release-type=hotfix" >> $GITHUB_OUTPUT
            echo "✅ Hotfix branch merge detected: $BRANCH_NAME"
          fi
        else
          echo "is-release=false" >> $GITHUB_OUTPUT
          echo "❌ Not a release or hotfix branch merge, skipping publication"
        fi

  # Job 1: Run comprehensive tests
  test:
    name: 🧪 Test Suite
    runs-on: ubuntu-latest
    needs: check-release
    if: needs.check-release.outputs.is-release == 'true' || github.event_name == 'workflow_dispatch'
    strategy:
      matrix:
        python-version: ['3.10', '3.11', '3.12']
    
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4
      
    - name: 🐍 Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ matrix.python-version }}
        
    - name: 📦 Install Poetry
      uses: snok/install-poetry@v1
      with:
        version: latest
        virtualenvs-create: true
        virtualenvs-in-project: true
        
    - name: 🔧 Load cached venv
      id: cached-poetry-dependencies
      uses: actions/cache@v4
      with:
        path: .venv
        key: venv-${{ runner.os }}-${{ matrix.python-version }}-${{ hashFiles('**/poetry.lock') }}
        
    - name: 📥 Install dependencies
      if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
      run: poetry install --no-interaction --no-root
      
    - name: 📦 Install project
      run: poetry install --no-interaction
      
    - name: 🧪 Run tests
      run: |
        poetry run pytest tests/ -v --tb=short
        echo "✅ All tests passed!"
        
    - name: 📊 Test coverage report
      run: |
        poetry run pytest tests/ --cov=classroom_pilot --cov-report=xml --cov-report=term
        
    - name: 📤 Upload coverage to Codecov
      if: matrix.python-version == '3.12'
      uses: codecov/codecov-action@v4
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella

  # Job 2: Build and publish to PyPI
  publish:
    name: 📦 Build & Publish to PyPI
    needs: [check-release, test]
    runs-on: ubuntu-latest
    if: needs.check-release.outputs.is-release == 'true' || github.event_name == 'workflow_dispatch'
    
    # environment:
    #   name: pypi
    #   url: https://pypi.org/project/classroom-pilot/
      
    permissions:
      id-token: write  # For trusted publishing
      contents: write  # For creating releases
      actions: read    # For workflow context
      attestations: write  # For build attestations
      
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for changelog
        
    - name: 🐍 Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.12'
        
    - name: 📦 Install Poetry
      uses: snok/install-poetry@v1
      with:
        version: latest
        virtualenvs-create: true
        virtualenvs-in-project: true
        
    - name: 🔧 Configure Poetry
      run: |
        poetry config virtualenvs.create true
        poetry config virtualenvs.in-project true
        
    - name: 📥 Install dependencies
      run: poetry install --no-interaction
      
    - name: 📝 Extract version from pyproject.toml
      id: version
      run: |
        if [[ ${{ github.event_name }} == 'workflow_dispatch' && -n "${{ github.event.inputs.version }}" ]]; then
          VERSION="${{ github.event.inputs.version }}"
          echo "Using manual version: $VERSION"
        else
          VERSION=$(poetry version -s)
          echo "Using pyproject.toml version: $VERSION"
        fi
        # Validate version string (must look like 1.2.3 or 1.2.3b1 etc, not 'main' or 'refs/heads/main')
        if [[ ! $VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+([a-zA-Z0-9]*)?$ ]]; then
          echo "Invalid version string: $VERSION. Skipping release creation."
          echo "version=SKIP" >> $GITHUB_OUTPUT
          echo "VERSION=SKIP" >> $GITHUB_ENV
        else
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "VERSION=$VERSION" >> $GITHUB_ENV
        fi
        
    - name: 🚑 Handle hotfix version increment
      if: needs.check-release.outputs.release-type == 'hotfix'
      run: |
        echo "🚑 Processing hotfix release..."
        CURRENT_VERSION="${{ steps.version.outputs.version }}"
        echo "Current version from pyproject.toml: $CURRENT_VERSION"
        
        # For hotfixes, we might want to auto-increment patch version if not already done
        # But for now, we'll trust that the release branch has the correct version
        # This is a placeholder for future enhancement
        echo "Using hotfix version as-is: $CURRENT_VERSION"
        
    - name: 🏷️ Create and push git tag
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        TAG_NAME="$VERSION"
        
        echo "Creating git tag: $TAG_NAME"
        
        # Check if tag already exists
        if git tag -l | grep -q "^$TAG_NAME$"; then
          echo "⚠️ Tag $TAG_NAME already exists, skipping tag creation"
        else
          # Configure git for tagging
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Create annotated tag with release message
          git tag -a "$TAG_NAME" -m "🎉 Release $VERSION

        This release was automatically created when release branch was merged to main.
        
        📦 Package Information
        - Version: $VERSION
        - PyPI: https://pypi.org/project/classroom-pilot/$VERSION/
        - Repository: ${{ github.server_url }}/${{ github.repository }}
        
        🤖 Automation
        Created by: ${{ github.actor }}
        Workflow: ${{ github.workflow }}
        Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          # Push the tag
          git push origin "$TAG_NAME"
          echo "✅ Created and pushed tag: $TAG_NAME"
        fi
        
    - name: 🔄 Update version if needed
      if: github.event.inputs.version != ''
      run: |
        if [[ -n "${{ github.event.inputs.version }}" ]]; then
          echo "Setting version from manual input: ${{ github.event.inputs.version }}"
          poetry version ${{ github.event.inputs.version }}
          echo "Current version after update: $(poetry version -s)"
        else
          echo "Using version from pyproject.toml: $(poetry version -s)"
        fi
        
    - name: 🧹 Clean previous builds
      run: |
        rm -rf dist/ build/ *.egg-info/ __pycache__/
        find . -name "*.pyc" -delete
        find . -name "__pycache__" -type d -exec rm -rf {} + 2>/dev/null || true
        echo "✅ Cleaned previous build artifacts and cache"
        
    - name: 🔄 Refresh Poetry environment
      run: |
        poetry env remove --all || true
        poetry cache clear pypi --all
        poetry install --no-interaction
        echo "✅ Poetry environment refreshed"
        
    - name: ✅ Validate package configuration
      run: |
        echo "🔍 Checking pyproject.toml format..."
        if grep -q "\[project\]" pyproject.toml; then
          echo "✅ Using modern [project] format"
        else
          echo "❌ Still using deprecated [tool.poetry] format"
          exit 1
        fi
        poetry check
        echo "✅ Package configuration is valid"
        echo "Final version: $(poetry version -s)"
        echo "Package name: $(poetry version | cut -d' ' -f1)"
        
    - name: 🏗️ Build package
      run: |
        echo "Building package with version: $(poetry version -s)"
        poetry build
        echo "✅ Package built successfully"
        echo "📦 Built artifacts:"
        ls -la dist/
        echo "🔍 Checking wheel metadata:"
        python -m zipfile -l dist/*.whl | head -10
        
    - name: 🔍 Debug package metadata
      run: |
        echo "🔍 Inspecting package metadata..."
        cd dist/
        for file in *.whl; do
          echo "=== Checking $file ==="
          python -m zipfile -e "$file" temp_extract/
          if [ -f temp_extract/*/METADATA ]; then
            echo "METADATA file found:"
            cat temp_extract/*/METADATA | head -20
          else
            echo "❌ METADATA file not found in wheel"
            find temp_extract/ -name "*" -type f | head -10
          fi
          rm -rf temp_extract/
        done
        
    - name: 🔍 Verify build contents
      run: |
        echo "📦 Package contents:"
        tar -tzf dist/*.tar.gz | head -20
        echo "🔍 Wheel contents:"
        unzip -l dist/*.whl | head -20
        
    - name: ✅ Validate package metadata
      run: |
        echo "🔍 Validating package metadata..."
        # Install twine for checking
        pip install twine build
        echo "✅ Package metadata validation tools installed"
        
        # Try alternative build method if Poetry build fails validation
        echo "🔍 Testing Poetry build..."
        if ! twine check dist/*; then
          echo "❌ Poetry build failed validation, trying alternative build..."
          rm -rf dist/
          
          echo "🏗️ Building with pip build..."
          python -m build
          echo "📦 Alternative build artifacts:"
          ls -la dist/
          
          echo "🔍 Re-checking metadata..."
          twine check dist/*
        fi
        echo "✅ Package metadata validation completed"
        
    - name: 🚀 Publish to PyPI
      uses: pypa/gh-action-pypi-publish@v1.13.0
      with:
        # Use API token if available, otherwise fall back to trusted publishing
        password: ${{ secrets.PYPI_API_TOKEN || '' }}
        
    - name: 📋 Create Release Notes
      id: release_notes
      run: |
        cat > release_notes.md << 'EOF'
        ## 🎉 classroom-pilot v${{ steps.version.outputs.version }}
        
        ### 📦 Installation
        ```bash
        pip install classroom-pilot==${{ steps.version.outputs.version }}
        ```
        
        ### 🚀 What's New
        - Comprehensive GitHub Classroom automation
        - Modern Python CLI with 153 tests
        - Modular architecture for educational workflows
        
        ### 📊 Package Stats
        - **Tests**: 153 passing tests across 9 packages
        - **CLI Commands**: 7 command groups for complete workflow automation
        - **Python Support**: 3.10, 3.11, 3.12
        
        ### 📚 Documentation
        - [PyPI Package](https://pypi.org/project/classroom-pilot/)
        - [GitHub Repository](https://github.com/hugo-valle/classroom-pilot)
        - [Installation Guide](https://github.com/hugo-valle/classroom-pilot#installation)
        
        ---
        *Automated release created by GitHub Actions*
        EOF
        
    - name: 🏷️ Create GitHub Release
      if: steps.version.outputs.version != 'SKIP'
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ steps.version.outputs.version }}
        name: 🎉 classroom-pilot v${{ steps.version.outputs.version }}
        body_path: release_notes.md
        draft: false
        prerelease: ${{ contains(steps.version.outputs.version, 'a') || contains(steps.version.outputs.version, 'b') || contains(steps.version.outputs.version, 'rc') }}
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: 📢 Post-publish verification
      run: |
        source .github/scripts/workflow_utils.sh
        
        echo "🔍 Verifying package availability..."
        # Try multiple times with increasing delays
        for i in {1..5}; do
          echo "Attempt $i/5..."
          # Check if the specific version is available
          if pip install classroom-pilot==${{ steps.version.outputs.version }} --dry-run --quiet 2>/dev/null; then
            echo "✅ Package version ${{ steps.version.outputs.version }} found on PyPI!"
            break
          elif [ $i -eq 5 ]; then
            echo "⚠️ Package not yet available on PyPI, but publication likely succeeded"
            echo "Note: PyPI propagation can take several minutes"
            echo "Check manually: https://pypi.org/project/classroom-pilot/${{ steps.version.outputs.version }}/"
          else
            echo "Waiting 30 seconds before retry..."
            sleep 30
          fi
        done
        
        echo "✅ Publication process completed!"
        echo "📦 Package: https://pypi.org/project/classroom-pilot/${{ steps.version.outputs.version }}/"
        
    - name: 💬 Notify on failure
      if: failure() && !cancelled()
      run: |
        source .github/scripts/workflow_utils.sh
        log_error "❌ Publication failed for classroom-pilot v${VERSION:-unknown}"
        
  # Job 3: Update documentation
  update-docs:
    name: 📚 Update Documentation
    needs: publish
    runs-on: ubuntu-latest
    # Always run when publish succeeds (release branch merged to main)
    
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        ref: main

    - name: 📝 Update publication history and create PR
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        TAG_NAME=${GITHUB_REF#refs/tags/}
        if [[ $TAG_NAME == v* ]]; then
          VERSION=${TAG_NAME#v}
        else
          VERSION=$TAG_NAME
        fi
        DATE=$(date '+%B %d, %Y')
        BRANCH=docs/update-publication-history-v$VERSION-$(date +%s)

        # Update PYPI_PUBLICATION.md
        sed -i "/### Future Releases/i ### v$VERSION ($DATE)\n- **Status**: ✅ Published via GitHub Actions\n- **Features**: Automated release workflow\n- **PyPI**: https://pypi.org/project/classroom-pilot/$VERSION/\n" docs/PYPI_PUBLICATION.md

        # Create a new branch
        git checkout -b "$BRANCH"
        git config user.email "action@github.com"
        git config user.name "GitHub Action"
        git add docs/PYPI_PUBLICATION.md
        git commit -m "docs: update publication history for v$VERSION" || exit 0
        git push origin "$BRANCH"

        # Create a pull request using GitHub CLI
        gh pr create --base main --head "$BRANCH" --title "docs: update publication history for v$VERSION" --body "Automated update of publication history for v$VERSION after release."

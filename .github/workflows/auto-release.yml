name: üöë Automated Hotfix Release

# This workflow automatically creates hotfix releases when hotfix/* branches are merged to main
# Regular releases should use the release workflow triggered by release/* branch merges

on:
  push:
    branches:
      - main
    # Only trigger if merged from hotfix/* branches

permissions:
  contents: write      # Required to create releases and tags
  actions: read        # Required for workflow context
  pull-requests: read  # Required to fetch PR information
  id-token: write      # Required for PyPI trusted publishing

jobs:
  check-hotfix:
    name: üîç Check Hotfix Branch
    runs-on: ubuntu-latest
    outputs:
      is-hotfix: ${{ steps.check.outputs.is-hotfix }}
      branch-name: ${{ steps.check.outputs.branch-name }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üîç Check if hotfix branch merge or tag push
        id: check
        run: |
          # If triggered by a tag push, always proceed
          if [[ "$GITHUB_REF" == refs/tags/* ]]; then
            echo "Detected tag push: $GITHUB_REF"
            echo "is-hotfix=true" >> $GITHUB_OUTPUT
            TAG_NAME=${GITHUB_REF#refs/tags/}
            echo "branch-name=$TAG_NAME" >> $GITHUB_OUTPUT
            echo "‚úÖ Proceeding with hotfix release for tag: $TAG_NAME"
          else
            # Get the commit message to see if this was a merge from hotfix/*
            COMMIT_MSG=$(git log -1 --pretty=%B)
            echo "Commit message: $COMMIT_MSG"
            # Check if this is a merge commit from a hotfix branch
            if [[ $COMMIT_MSG =~ "Merge pull request".+"hotfix/" ]] || [[ $COMMIT_MSG =~ "Merge branch 'hotfix/" ]]; then
              echo "is-hotfix=true" >> $GITHUB_OUTPUT
              # Extract branch name from commit message
              BRANCH_NAME=$(echo "$COMMIT_MSG" | grep -oE "hotfix/[^'\"]*" | head -1)
              echo "branch-name=$BRANCH_NAME" >> $GITHUB_OUTPUT
              echo "‚úÖ Hotfix branch merge detected: $BRANCH_NAME"
            else
              echo "is-hotfix=false" >> $GITHUB_OUTPUT
              echo "‚ùå Not a hotfix branch merge, skipping hotfix release"
            fi
          fi

  release:
    name: üöë Hotfix Release
    runs-on: ubuntu-latest
    needs: check-hotfix
    if: needs.check-hotfix.outputs.is-hotfix == 'true'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get latest tag
        id: get_tag
        run: |
          TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "0.0.0")
          echo "latest=$TAG" >> $GITHUB_OUTPUT

      - name: Detect release version from branch
        id: version_info
        run: |
          # Check if this push came from merging a release or hotfix branch
          # Look for merge commit patterns or branch references in commit messages
          MERGE_INFO=$(git log -1 --pretty=format:"%s %b" | head -5)
          echo "Merge info: $MERGE_INFO"
          
          # Try multiple patterns to detect release branch merges
          BRANCH_REF=""
          
          # Pattern 1: Direct merge commit message
          if [[ "$MERGE_INFO" =~ Merge\ pull\ request.*release/([0-9]+\.[0-9]+\.[0-9]+[a-zA-Z0-9]*) ]]; then
            BRANCH_REF="release/${BASH_REMATCH[1]}"
          # Pattern 2: Branch reference in git log
          elif BRANCH_REF=$(git log -1 --pretty=%D | grep -oE 'origin/(release|hotfix)/[0-9]+\.[0-9]+\.[0-9]+[a-zA-Z0-9]*' | head -1); then
            echo "Found branch ref in log: $BRANCH_REF"
          # Pattern 3: Check recent merge commits for release patterns
          elif BRANCH_REF=$(git log --oneline -10 | grep -oE '(release|hotfix)/[0-9]+\.[0-9]+\.[0-9]+[a-zA-Z0-9]*' | head -1); then
            echo "Found branch ref in recent commits: $BRANCH_REF"
          fi
          
          if [[ -n "$BRANCH_REF" && "$BRANCH_REF" =~ ^(origin/)?(release|hotfix)/([0-9]+\.[0-9]+\.[0-9]+[a-zA-Z0-9]*)$ ]]; then
            VERSION="${BASH_REMATCH[3]}"
            TYPE="${BASH_REMATCH[2]}"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "type=$TYPE" >> $GITHUB_OUTPUT
            echo "‚úÖ Detected $TYPE branch merge with version: $VERSION"
          else
            echo "‚ùå Not a release or hotfix branch merge. Checking pyproject.toml..."
            # Fallback: check if pyproject.toml has a beta/rc version
            if grep -q 'version = ".*[a-zA-Z]' pyproject.toml; then
              VERSION=$(grep 'version = ' pyproject.toml | sed 's/.*version = "\([^"]*\)".*/\1/')
              echo "version=$VERSION" >> $GITHUB_OUTPUT
              echo "type=release" >> $GITHUB_OUTPUT
              echo "‚úÖ Found beta/rc version in pyproject.toml: $VERSION"
            else
              echo "‚ùå No release version detected. Skipping."
              exit 0
            fi
          fi

      - name: Collect merged PRs since last tag
        id: prs
        run: |
          PREV_TAG=${{ steps.get_tag.outputs.latest }}
          NEW_TAG=${{ steps.version_info.outputs.version }}

          echo "Fetching PRs merged between $PREV_TAG..HEAD"

          gh api \
            repos/${{ github.repository }}/pulls \
            --jq '.[] | select(.merged_at != null) | {title: .title, number: .number, labels: [.labels[].name]}' \
            > prs.json

          echo "prs=$(cat prs.json)" >> $GITHUB_OUTPUT
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate grouped changelog
        id: changelog
        run: |
          PREV_TAG=${{ steps.get_tag.outputs.latest }}
          NEW_TAG=${{ steps.version_info.outputs.version }}
          TYPE=${{ steps.version_info.outputs.type }}

          if [ -z "$NEW_TAG" ] || [ -z "$TYPE" ]; then
            echo "No release version detected; skipping changelog generation."
            exit 0
          fi

          ./.github/scripts/generate_grouped_changelog.sh "$PREV_TAG" "$NEW_TAG" "$TYPE"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version_info.outputs.version }}
          name: ${{ steps.version_info.outputs.type }} v${{ steps.version_info.outputs.version }}
          body_path: docs/CHANGELOG.md
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: latest
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Load cached venv
        id: cached-poetry-dependencies
        uses: actions/cache@v4
        with:
          path: .venv
          key: venv-${{ runner.os }}-3.11-${{ hashFiles('**/poetry.lock') }}

      - name: Install dependencies
        if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
        run: poetry install --no-interaction --no-root

      - name: Install project
        run: poetry install --no-interaction

      - name: Verify version matches
        run: |
          PROJECT_VERSION=$(poetry version -s)
          RELEASE_VERSION="${{ steps.version_info.outputs.version }}"
          echo "Project version: $PROJECT_VERSION"
          echo "Release version: $RELEASE_VERSION"
          
          if [ "$PROJECT_VERSION" != "$RELEASE_VERSION" ]; then
            echo "‚ùå Version mismatch! Project: $PROJECT_VERSION, Release: $RELEASE_VERSION"
            exit 1
          fi
          echo "‚úÖ Version verified: $PROJECT_VERSION"

      - name: Build package
        run: |
          echo "üî® Building package..."
          poetry build
          echo "üì¶ Package built successfully"
          ls -la dist/

      - name: Publish to PyPI
        env:
          POETRY_PYPI_TOKEN_PYPI: ${{ secrets.PYPI_API_TOKEN }}
        run: |
          echo "üöÄ Publishing to PyPI..."
          poetry publish --no-interaction
          echo "‚úÖ Package published successfully"

      - name: Verify PyPI publication
        run: |
          VERSION="${{ steps.version_info.outputs.version }}"
          echo "üîç Verifying publication on PyPI..."
          sleep 30  # Wait for PyPI to update
          
          if pip install classroom-pilot==$VERSION --dry-run --quiet 2>/dev/null; then
            echo "‚úÖ Package verification successful"
            echo "üì¶ Available at: https://pypi.org/project/classroom-pilot/$VERSION/"
          else
            echo "‚ö†Ô∏è Package not yet available on PyPI (may take a few minutes)"
            echo "Check manually: https://pypi.org/project/classroom-pilot/$VERSION/"
          fi

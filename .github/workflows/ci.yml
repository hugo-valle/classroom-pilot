name: 🔄 CI

on:
  push:
    branches: [ main, develop, feature/python-migration ]
  pull_request:
    branches: [ main, develop ]

permissions:
  contents: read       # Required to checkout code
  issues: read         # Required for security scanning
  pull-requests: read  # Required for PR context

env:
  # Performance monitoring
  CI_START_TIME: ${{ github.event.head_commit.timestamp }}
  CACHE_VERSION: v2

jobs:
  test:
    name: 🧪 Test Scripts (${{ matrix.shell }})
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false  # Continue other matrix jobs even if one fails
      matrix:
        shell: [bash, zsh]
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 📦 Load workflow utilities
        run: |
          chmod +x .github/scripts/workflow_utils.sh
          source .github/scripts/workflow_utils.sh
          echo "STEP_START_TIME=$(date +%s)" >> $GITHUB_ENV

      - name: 🗂️ Setup cache directories
        run: |
          source .github/scripts/workflow_utils.sh
          setup_cache_directories "/tmp/test-artifacts"

      - name: 💾 Cache shell and dependencies
        uses: actions/cache@v4
        with:
          path: |
            /tmp/test-artifacts
          key: ${{ runner.os }}-shells-${{ matrix.shell }}-${{ env.CACHE_VERSION }}
          restore-keys: |
            ${{ runner.os }}-shells-${{ matrix.shell }}-
            ${{ runner.os }}-shells-

      - name: 🐚 Install shell with retry
        run: |
          source .github/scripts/workflow_utils.sh
          if [ "${{ matrix.shell }}" = "zsh" ]; then
            install_with_retry "apt" "zsh" ""
          fi
          print_message "success" "${{ matrix.shell }} installation completed"

      - name: ✅ Validate environment
        run: |
          source .github/scripts/workflow_utils.sh
          validate_environment "${{ matrix.shell }} bash" "git curl"

      - name: 🔍 Test script syntax with retry
        run: |
          source .github/scripts/workflow_utils.sh
          print_message "step" "Testing script syntax with ${{ matrix.shell }}"
          
          syntax_check_cmd="
            for script in classroom_pilot/scripts/*.sh; do
              if [ -f \"\$script\" ]; then
                print_message 'info' 'Checking \$script'
                ${{ matrix.shell }} -n \"\$script\"
              fi
            done
          "
          
          retry_with_backoff "$syntax_check_cmd" "script syntax validation"

      - name: 🧪 Test help commands with enhanced error handling
        run: |
          source .github/scripts/workflow_utils.sh
          print_message "step" "Setting up mock environment for help command testing"
          
          # Create comprehensive mock directory structure
          mkdir -p ../mock-assignment/{scripts,tests,docs}
          cd ../mock-assignment
          
          # Create realistic mock assignment.conf
          cat > assignment.conf << 'EOF'
          CLASSROOM_URL="https://classroom.github.com/classrooms/12345/assignments/test"
          TEMPLATE_REPO_URL="https://github.com/test-org/test-template"
          GITHUB_ORGANIZATION="test-org"
          ASSIGNMENT_NOTEBOOK="test.ipynb"
          INSTRUCTOR_TESTS_TOKEN="test-token"
          SECRETS_CONFIG="test-secrets.json"
          STEP_MANAGE_SECRETS="true"
          EOF
          
          # Create comprehensive test files
          echo '{"assignment":"test","version":"1.0"}' > assignment.json
          echo '{"cells":[],"metadata":{},"nbformat":4,"nbformat_minor":4}' > test.ipynb
          echo '{"test_secret": "test_value"}' > test-secrets.json
          
          # Copy scripts for testing
          cp -r ../classroom_pilot/classroom_pilot/scripts ./
          
          # Test help commands with proper error handling and retry
          test_help_command() {
            local script_path="$1"
            local script_name=$(basename "$script_path")
            
            if [ -f "$script_path" ]; then
              print_message "info" "Testing $script_name --help"
              retry_with_backoff "timeout 30s bash '$script_path' --help >/dev/null 2>&1" "help command for $script_name" 2
            else
              print_message "warning" "Script not found: $script_path"
            fi
          }
          
          # Test critical scripts
          test_help_command "scripts/setup-assignment.sh"
          test_help_command "scripts/assignment-orchestrator.sh" 
          test_help_command "scripts/fetch-student-repos.sh"
          
          print_message "success" "Help command testing completed"

      - name: 📊 Generate test summary
        if: always()
        run: |
          source .github/scripts/workflow_utils.sh
          
          # Calculate step timing
          step_duration=$(report_step_timing "Test Scripts (${{ matrix.shell }})" "$STEP_START_TIME")
          
          # Create comprehensive summary
          if [ "${{ job.status }}" = "success" ]; then
            create_step_summary "Test Scripts (${{ matrix.shell }})" "success" "| Shell | ${{ matrix.shell }} |\n| Duration | ${step_duration}s |"
          else
            error_report=$(generate_error_report "Test Scripts (${{ matrix.shell }})" "Script testing failed" "Matrix: ${{ matrix.shell }}" "- Check script syntax\n- Verify shell installation\n- Review help command implementation")
            echo "$error_report" >> $GITHUB_STEP_SUMMARY
            create_step_summary "Test Scripts (${{ matrix.shell }})" "failure"
          fi

  lint:
    name: 🔍 Lint & Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 📦 Load workflow utilities
        run: |
          chmod +x .github/scripts/workflow_utils.sh
          source .github/scripts/workflow_utils.sh
          echo "STEP_START_TIME=$(date +%s)" >> $GITHUB_ENV

      - name: 💾 Cache linting tools
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/shellcheck
          key: ${{ runner.os }}-lint-tools-${{ env.CACHE_VERSION }}
          restore-keys: |
            ${{ runner.os }}-lint-tools-

      - name: 🔧 Install linting tools with retry
        run: |
          source .github/scripts/workflow_utils.sh
          install_with_retry "apt" "shellcheck" ""

      - name: 🔍 Run Shellcheck with enhanced reporting
        run: |
          source .github/scripts/workflow_utils.sh
          print_message "step" "Running Shellcheck analysis"
          
          shellcheck_cmd="
            find classroom_pilot/scripts -name '*.sh' -type f | while read -r script; do
              print_message 'info' 'Linting \$script'
              shellcheck -e SC1091,SC2034,SC2155,SC2086,SC2162,SC2329 -f gcc '\$script'
            done
          "
          
          retry_with_backoff "$shellcheck_cmd" "Shellcheck analysis" 2

      - name: 📊 Generate lint summary
        if: always()
        run: |
          source .github/scripts/workflow_utils.sh
          step_duration=$(report_step_timing "Lint & Code Quality" "$STEP_START_TIME")
          
          if [ "${{ job.status }}" = "success" ]; then
            create_step_summary "Lint & Code Quality" "success" "| Tool | Shellcheck |\n| Duration | ${step_duration}s |"
          else
            create_step_summary "Lint & Code Quality" "failure"
          fi

  security:
    name: 🛡️ Security Scan
    runs-on: ubuntu-latest
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 📦 Load workflow utilities
        run: |
          chmod +x .github/scripts/workflow_utils.sh
          source .github/scripts/workflow_utils.sh
          echo "STEP_START_TIME=$(date +%s)" >> $GITHUB_ENV

      - name: 💾 Cache security scan data
        uses: actions/cache@v4
        with:
          path: |
            /tmp/trufflehog-cache
          key: ${{ runner.os }}-security-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-security-

      - name: 🔍 Scan for secrets with retry
        run: |
          source .github/scripts/workflow_utils.sh
          
          # Enhanced secret scanning with retry logic
          scan_cmd="docker run --rm -v \"\$PWD:/pwd\" trufflesecurity/trufflehog:latest github --repo=https://github.com/${{ github.repository }} --since-commit=${{ github.event.before || 'HEAD~10' }} --only-verified"
          
          print_message "step" "Running enhanced security scan"
          if retry_with_backoff "$scan_cmd" "security scan" 2; then
            print_message "success" "Security scan completed successfully"
          else
            print_message "warning" "Security scan completed with warnings (non-blocking)"
          fi
        continue-on-error: true

      - name: 📊 Generate security summary
        if: always()
        run: |
          source .github/scripts/workflow_utils.sh
          step_duration=$(report_step_timing "Security Scan" "$STEP_START_TIME")
          create_step_summary "Security Scan" "success" "| Scan Type | Secret Detection |\n| Duration | ${step_duration}s |"

  validate-docs:
    name: 📚 Documentation Validation
    runs-on: ubuntu-latest
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 📦 Load workflow utilities  
        run: |
          chmod +x .github/scripts/workflow_utils.sh
          source .github/scripts/workflow_utils.sh
          echo "STEP_START_TIME=$(date +%s)" >> $GITHUB_ENV

      - name: 💾 Cache documentation validation
        uses: actions/cache@v4
        with:
          path: |
            /tmp/docs-cache
          key: ${{ runner.os }}-docs-${{ hashFiles('docs/**') }}-${{ env.CACHE_VERSION }}
          restore-keys: |
            ${{ runner.os }}-docs-

      - name: ✅ Comprehensive documentation validation
        run: |
          source .github/scripts/workflow_utils.sh
          print_message "step" "Running comprehensive documentation validation"
          
          validation_errors=0
          
          # Enhanced CHANGELOG validation
          if [ ! -f "docs/CHANGELOG.md" ]; then
            print_message "error" "CHANGELOG.md not found in docs/"
            validation_errors=$((validation_errors + 1))
          else
            print_message "info" "Validating CHANGELOG.md format"
            
            if ! grep -q "## \[Unreleased\]" docs/CHANGELOG.md; then
              print_message "error" "CHANGELOG.md missing [Unreleased] section"
              validation_errors=$((validation_errors + 1))
            fi
            
            if ! grep -q "### Added\|### Changed\|### Fixed\|### Removed" docs/CHANGELOG.md; then
              print_message "warning" "CHANGELOG.md could benefit from standard sections (Added, Changed, Fixed, Removed)"
            fi
            
            print_message "success" "CHANGELOG.md validation completed"
          fi
          
          # Enhanced README validation
          readme_found=false
          for readme in README.md docs/README.md; do
            if [ -f "$readme" ]; then
              print_message "info" "Found README at: $readme"
              readme_found=true
              
              # Check for essential sections
              if ! grep -qi "installation\|install" "$readme"; then
                print_message "warning" "$readme missing installation instructions"
              fi
              
              if ! grep -qi "usage\|example" "$readme"; then
                print_message "warning" "$readme missing usage examples"
              fi
              break
            fi
          done
          
          if [ "$readme_found" = false ]; then
            print_message "error" "No README.md found"
            validation_errors=$((validation_errors + 1))
          fi
          
          # Check for additional documentation files
          doc_files="CONTRIBUTING.md LICENSE SECURITY.md"
          for doc_file in $doc_files; do
            if [ -f "$doc_file" ] || [ -f "docs/$doc_file" ]; then
              print_message "success" "Found: $doc_file"
            else
              print_message "info" "Optional documentation missing: $doc_file"
            fi
          done
          
          if [ $validation_errors -gt 0 ]; then
            print_message "error" "Documentation validation failed with $validation_errors errors"
            exit 1
          else
            print_message "success" "All documentation validation checks passed"
          fi

      - name: 📊 Generate documentation summary
        if: always()
        run: |
          source .github/scripts/workflow_utils.sh
          step_duration=$(report_step_timing "Documentation Validation" "$STEP_START_TIME")
          
          if [ "${{ job.status }}" = "success" ]; then
            create_step_summary "Documentation Validation" "success" "| Validation | Complete |\n| Duration | ${step_duration}s |"
          else
            error_report=$(generate_error_report "Documentation Validation" "Documentation validation failed" "Missing or malformed documentation files" "- Add missing CHANGELOG.md in docs/\n- Ensure README.md exists\n- Follow standard documentation structure")
            echo "$error_report" >> $GITHUB_STEP_SUMMARY
            create_step_summary "Documentation Validation" "failure"
          fi

  # Final summary job
  ci-summary:
    name: 📋 CI Summary
    if: always()
    needs: [test, lint, security, validate-docs]
    runs-on: ubuntu-latest
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 📦 Load workflow utilities
        run: |
          chmod +x .github/scripts/workflow_utils.sh
          source .github/scripts/workflow_utils.sh

      - name: 📊 Generate comprehensive CI summary
        run: |
          source .github/scripts/workflow_utils.sh
          
          # Determine overall status
          overall_status="success"
          if [[ "${{ needs.test.result }}" != "success" ]] || [[ "${{ needs.lint.result }}" != "success" ]] || [[ "${{ needs.validate-docs.result }}" != "success" ]]; then
            overall_status="failure"
          fi
          
          # Security is allowed to fail, so only warn
          security_status="${{ needs.security.result }}"
          if [[ "$security_status" != "success" ]]; then
            print_message "warning" "Security scan completed with warnings (non-blocking)"
          fi
          
          # Create comprehensive summary
          {
            echo "# 🔄 CI Pipeline Summary"
            echo ""
            echo "## Job Status"
            echo "| Job | Status | Duration |"
            echo "|-----|--------|----------|"
            echo "| 🧪 Test Scripts | ${{ needs.test.result }} | - |"
            echo "| 🔍 Lint & Code Quality | ${{ needs.lint.result }} | - |"
            echo "| 🛡️ Security Scan | ${{ needs.security.result }} | - |"
            echo "| 📚 Documentation | ${{ needs.validate-docs.result }} | - |"
            echo ""
            
            if [ "$overall_status" = "success" ]; then
              echo "✅ **Overall Status:** All critical checks passed!"
            else
              echo "❌ **Overall Status:** Some checks failed"
              echo ""
              echo "## Troubleshooting"
              echo "- Check individual job logs for detailed error information"
              echo "- Ensure all scripts pass syntax validation"
              echo "- Verify documentation structure follows project standards"
              echo "- Review linting errors and apply suggested fixes"
            fi
            
            echo ""
            echo "## Next Steps"
            if [ "$overall_status" = "success" ]; then
              echo "- ✅ Ready for merge/deployment"
              echo "- 🚀 All quality gates passed successfully"
            else
              echo "- 🔧 Address failing checks before proceeding"
              echo "- 📝 Review job-specific error reports above"
              echo "- 🔄 Re-run workflow after fixes"
            fi
          } >> $GITHUB_STEP_SUMMARY
          
          print_message "$overall_status" "CI Pipeline completed with status: $overall_status"

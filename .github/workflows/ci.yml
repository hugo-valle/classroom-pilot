name: ðŸ”„ CI

on:
  push:
    branches: [ main, develop, feature/python-migration ]
  pull_request:
    branches: [ main, develop ]

permissions:
  contents: read       # Required to checkout code
  issues: read         # Required for security scanning
  pull-requests: read  # Required for PR context

env:
  # Performance monitoring
  CI_START_TIME: ${{ github.event.head_commit.timestamp }}
  CACHE_VERSION: v2

jobs:
  test:
    name: ðŸ§ª Test Scripts (${{ matrix.shell }})
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false  # Continue other matrix jobs even if one fails
      matrix:
        shell: [bash, zsh]
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ“¦ Load workflow utilities
        run: |
          chmod +x .github/scripts/workflow_utils.sh
          source .github/scripts/workflow_utils.sh
          echo "STEP_START_TIME=$(date +%s)" >> $GITHUB_ENV

      - name: ðŸ—‚ï¸ Setup cache directories
        run: |
          source .github/scripts/workflow_utils.sh
          setup_cache_directories "/tmp/test-artifacts"

      - name: ðŸ’¾ Cache shell and dependencies
        uses: actions/cache@v4
        with:
          path: |
            /tmp/test-artifacts
          key: ${{ runner.os }}-shells-${{ matrix.shell }}-${{ env.CACHE_VERSION }}
          restore-keys: |
            ${{ runner.os }}-shells-${{ matrix.shell }}-
            ${{ runner.os }}-shells-

      - name: ðŸš Install shell with retry
        run: |
          source .github/scripts/workflow_utils.sh
          if [ "${{ matrix.shell }}" = "zsh" ]; then
            install_with_retry "apt" "zsh" ""
          fi
          print_message "success" "${{ matrix.shell }} installation completed"

      - name: âœ… Validate environment
        run: |
          source .github/scripts/workflow_utils.sh
          validate_environment "${{ matrix.shell }} bash" "git curl"

      - name: ðŸ” Test script syntax with retry
        run: |
          source .github/scripts/workflow_utils.sh
          print_message "step" "Testing script syntax with ${{ matrix.shell }}"
          
          syntax_check_cmd="
            for script in classroom_pilot/scripts/*.sh; do
              if [ -f \"\$script\" ]; then
                print_message 'info' 'Checking \$script'
                ${{ matrix.shell }} -n \"\$script\"
              fi
            done
          "
          
          retry_with_backoff "$syntax_check_cmd" "script syntax validation"

      - name: ðŸ§ª Test help commands with enhanced error handling
        run: |
          source .github/scripts/workflow_utils.sh
          print_message "step" "Setting up mock environment for help command testing"
          
          # Create comprehensive mock directory structure
          mkdir -p ../mock-assignment/{scripts,tests,docs}
          cd ../mock-assignment
          
          # Create realistic mock assignment.conf
          cat > assignment.conf << 'EOF'
          CLASSROOM_URL="https://classroom.github.com/classrooms/12345/assignments/test"
          TEMPLATE_REPO_URL="https://github.com/test-org/test-template"
          GITHUB_ORGANIZATION="test-org"
          ASSIGNMENT_NOTEBOOK="test.ipynb"
          INSTRUCTOR_TESTS_TOKEN="test-token"
          SECRETS_CONFIG="test-secrets.json"
          STEP_MANAGE_SECRETS="true"
          EOF
          
          # Create comprehensive test files
          echo '{"assignment":"test","version":"1.0"}' > assignment.json
          echo '{"cells":[],"metadata":{},"nbformat":4,"nbformat_minor":4}' > test.ipynb
          echo '{"test_secret": "test_value"}' > test-secrets.json
          
          # Copy scripts for testing
          cp -r ./classroom_pilot/scripts ./ || {
            log_warning "Scripts directory not found, creating mock scripts for testing"
            mkdir -p scripts
            echo '#!/bin/bash\necho "Mock script help"' > scripts/mock_script.sh
            chmod +x scripts/mock_script.sh
          }
          
          # Test help commands with proper error handling and retry
          test_help_command() {
            local script_path="$1"
            local script_name=$(basename "$script_path")
            
            if [ -f "$script_path" ]; then
              print_message "info" "Testing $script_name --help"
              retry_with_backoff "timeout 30s bash '$script_path' --help >/dev/null 2>&1" "help command for $script_name" 2
            else
              print_message "warning" "Script not found: $script_path"
            fi
          }
          
          # Test critical scripts
          test_help_command "scripts/setup-assignment.sh"
          test_help_command "scripts/assignment-orchestrator.sh" 
          test_help_command "scripts/fetch-student-repos.sh"
          
          print_message "success" "Help command testing completed"

      - name: ðŸ“Š Generate test summary
        if: always()
        run: |
          source .github/scripts/workflow_utils.sh
          
          # Calculate step timing
          step_duration=$(report_step_timing "Test Scripts (${{ matrix.shell }})" "$STEP_START_TIME")
          
          # Create comprehensive summary
          if [ "${{ job.status }}" = "success" ]; then
            create_step_summary "Test Scripts (${{ matrix.shell }})" "success" "| Shell | ${{ matrix.shell }} |\n| Duration | ${step_duration}s |"
          else
            error_report=$(generate_error_report "Test Scripts (${{ matrix.shell }})" "Script testing failed" "Matrix: ${{ matrix.shell }}" "- Check script syntax\n- Verify shell installation\n- Review help command implementation")
            echo "$error_report" >> $GITHUB_STEP_SUMMARY
            create_step_summary "Test Scripts (${{ matrix.shell }})" "failure"
          fi

  lint:
    name: ðŸ” Lint & Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ“¦ Load workflow utilities
        run: |
          chmod +x .github/scripts/workflow_utils.sh
          source .github/scripts/workflow_utils.sh
          echo "STEP_START_TIME=$(date +%s)" >> $GITHUB_ENV

      - name: ðŸ’¾ Cache linting tools
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/shellcheck
          key: ${{ runner.os }}-lint-tools-${{ env.CACHE_VERSION }}
          restore-keys: |
            ${{ runner.os }}-lint-tools-

      - name: ðŸ”§ Install linting tools with retry
        run: |
          source .github/scripts/workflow_utils.sh
          install_with_retry "apt" "shellcheck" ""

      - name: ðŸ” Run Shellcheck with enhanced reporting
        run: |
          source .github/scripts/workflow_utils.sh
          print_message "step" "Running Shellcheck analysis"
          
          # Run ShellCheck on all shell scripts (allow warnings, fail on errors only)
          log_info "Running ShellCheck analysis on shell scripts..."
          shellcheck_output=$(find classroom_pilot/scripts -name '*.sh' -type f -exec shellcheck -e SC1091,SC2034,SC2155,SC2086,SC2162,SC2329,SC2002,SC2012 -f gcc {} + 2>&1) || true
          
          # Show the output for transparency
          if [ -n "$shellcheck_output" ]; then
            echo "$shellcheck_output"
            # Count actual errors vs warnings
            error_count=$(echo "$shellcheck_output" | grep -c "error:" || true)
            warning_count=$(echo "$shellcheck_output" | grep -c "note:\|warning:" || true)
            
            if [ "$error_count" -gt 0 ]; then
              log_error "âŒ ShellCheck found $error_count errors and $warning_count warnings"
              exit 1
            else
              log_warning "âš ï¸ ShellCheck found $warning_count warnings (non-blocking)"
            fi
          fi
          
          log_success "âœ… ShellCheck analysis completed successfully"

      - name: ðŸ“Š Generate lint summary
        if: always()
        run: |
          source .github/scripts/workflow_utils.sh
          step_duration=$(report_step_timing "Lint & Code Quality" "$STEP_START_TIME")
          
          if [ "${{ job.status }}" = "success" ]; then
            create_step_summary "Lint & Code Quality" "success" "| Tool | Shellcheck |\n| Duration | ${step_duration}s |"
          else
            create_step_summary "Lint & Code Quality" "failure"
          fi

  security:
    name: ðŸ›¡ï¸ Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 45
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ðŸ“¦ Load workflow utilities
        run: |
          chmod +x .github/scripts/workflow_utils.sh
          source .github/scripts/workflow_utils.sh
          echo "STEP_START_TIME=$(date +%s)" >> $GITHUB_ENV

      - name: ï¿½ï¸ Setup security cache directories
        run: |
          source .github/scripts/workflow_utils.sh
          setup_cache_directories "/tmp/security-cache"
          mkdir -p /tmp/security-cache/{trufflehog,trivy,sbom,sarif}

      - name: ï¿½ðŸ’¾ Cache security scan data
        uses: actions/cache@v4
        with:
          path: |
            /tmp/security-cache
            ~/.cache/trivy
          key: ${{ runner.os }}-security-${{ hashFiles('pyproject.toml', 'poetry.lock', 'requirements*.txt') }}-${{ env.CACHE_VERSION }}
          restore-keys: |
            ${{ runner.os }}-security-${{ hashFiles('pyproject.toml', 'poetry.lock', 'requirements*.txt') }}-
            ${{ runner.os }}-security-

      - name: ðŸ—ï¸ Setup Python for SBOM generation
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: ðŸ“¦ Install Poetry for dependency analysis
        uses: snok/install-poetry@v1
        with:
          version: latest
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: ðŸ“¦ Export Poetry dependencies for scanning
        run: |
          source .github/scripts/workflow_utils.sh
          print_message "step" "Exporting Poetry dependencies"
          poetry export -f requirements.txt --without-hashes -o requirements.txt
          print_message "success" "Dependencies exported to requirements.txt"

      - name: ðŸ”§ Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: ðŸ“¦ Load security utilities
        run: |
          chmod +x .github/scripts/security_utils.sh
          source .github/scripts/security_utils.sh

      - name: ðŸ“‹ Generate SBOM
        run: |
          source .github/scripts/security_utils.sh
          initialize_security_cache
          generate_sbom . all

      - name: ðŸ” Vulnerability scan
        timeout-minutes: 20
        run: |
          source .github/scripts/security_utils.sh
          run_trivy_scan . all CRITICAL,HIGH,MEDIUM

      - name: ðŸ” Trivy dependency vulnerability scan
        timeout-minutes: 15
        run: |
          source .github/scripts/workflow_utils.sh
          print_message "step" "Running Trivy dependency vulnerability scan"
          trivy fs \
            --cache-dir ~/.cache/trivy \
            --scanners vuln \
            --format sarif \
            --output /tmp/security-cache/sarif/trivy-deps.sarif \
            requirements.txt || true

      - name: ðŸ” Secret detection
        timeout-minutes: 15
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          source .github/scripts/security_utils.sh
          run_secret_detection . all

      - name: ðŸ” Enhanced secret detection with TruffleHog
        timeout-minutes: 10
        run: |
          source .github/scripts/workflow_utils.sh
          print_message "step" "Running enhanced TruffleHog secret detection"
          
          # TruffleHog filesystem scan (more reliable than GitHub scan)
          scan_cmd="docker run --rm -v \"\$PWD:/pwd\" trufflesecurity/trufflehog:latest filesystem /pwd --json --only-verified > /tmp/security-cache/trufflehog/secrets.json"
          
          if retry_with_backoff "$scan_cmd" "TruffleHog secret scan" 2; then
            print_message "success" "TruffleHog secret detection completed successfully"
          else
            print_message "warning" "TruffleHog secret detection completed with warnings"
          fi
        continue-on-error: true

      - name: ðŸ“¤ Upload security artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-artifacts-${{ github.sha }}
          path: |
            /tmp/security-cache/sbom/
            /tmp/security-cache/sarif/
            /tmp/security-cache/trufflehog/
          retention-days: 30

      - name: ðŸ“¤ Upload SARIF to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: /tmp/security-cache/sarif/*.sarif
        continue-on-error: true

      - name: ðŸ“Š Generate comprehensive security summary
        if: always()
        run: |
          source .github/scripts/workflow_utils.sh
          step_duration=$(report_step_timing "Security Scan" "$STEP_START_TIME")
          
          # Count findings from SARIF files with improved parsing
          fs_findings=0
          dep_findings=0
          secret_findings=0
          
          if [[ -f "/tmp/security-cache/sarif/trivy-fs.sarif" ]]; then
            fs_findings=$(jq -r '
              .runs[]?.results[]? as $r |
              ($r.level //
               $r.properties.severity //
               ( .runs[]?.tool.driver.rules[]? | select(.id==$r.ruleId) | (.properties.severity // .defaultConfiguration.level) ) //
               "info")' /tmp/security-cache/sarif/trivy-fs.sarif 2>/dev/null | wc -l || echo "0")
          fi
          
          if [[ -f "/tmp/security-cache/sarif/trivy-deps.sarif" ]]; then
            dep_findings=$(jq '.runs[0].results | length' /tmp/security-cache/sarif/trivy-deps.sarif 2>/dev/null || echo "0")
          fi
          
          if [[ -f "/tmp/security-cache/sarif/gitleaks.sarif" ]]; then
            secret_findings=$(jq '.runs[0].results | length' /tmp/security-cache/sarif/gitleaks.sarif 2>/dev/null || echo "0")
          fi
          
          # Generate SBOM summary
          sbom_files=0
          if [[ -f "/tmp/security-cache/sbom/spdx/sbom-spdx.json" ]]; then
            sbom_files=$((sbom_files + 1))
          fi
          if [[ -f "/tmp/security-cache/sbom/cyclonedx/sbom-cyclonedx.json" ]]; then
            sbom_files=$((sbom_files + 1))
          fi
          
          security_summary="| Security Tool | Findings | Status |\n"
          security_summary+="| --- | --- | --- |\n"
          security_summary+="| Trivy Filesystem | ${fs_findings} | âœ… |\n"
          security_summary+="| Trivy Dependencies | ${dep_findings} | âœ… |\n"
          security_summary+="| Secret Detection | ${secret_findings} | âœ… |\n"
          security_summary+="| SBOM Generated | ${sbom_files} files | âœ… |\n"
          security_summary+="| **Duration** | **${step_duration}s** | âœ… |"
          
          create_step_summary "Comprehensive Security Scan" "success" "$security_summary"
          print_message "success" "Comprehensive security scan completed with ${fs_findings} filesystem findings, ${dep_findings} dependency findings, ${secret_findings} secret findings"

  validate-docs:
    name: ðŸ“š Documentation Validation
    runs-on: ubuntu-latest
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ“¦ Load workflow utilities  
        run: |
          chmod +x .github/scripts/workflow_utils.sh
          source .github/scripts/workflow_utils.sh
          echo "STEP_START_TIME=$(date +%s)" >> $GITHUB_ENV

      - name: ðŸ’¾ Cache documentation validation
        uses: actions/cache@v4
        with:
          path: |
            /tmp/docs-cache
          key: ${{ runner.os }}-docs-${{ hashFiles('docs/**') }}-${{ env.CACHE_VERSION }}
          restore-keys: |
            ${{ runner.os }}-docs-

      - name: âœ… Comprehensive documentation validation
        run: |
          source .github/scripts/workflow_utils.sh
          print_message "step" "Running comprehensive documentation validation"
          
          validation_errors=0
          
          # Enhanced CHANGELOG validation
          if [ ! -f "docs/CHANGELOG.md" ]; then
            print_message "error" "CHANGELOG.md not found in docs/"
            validation_errors=$((validation_errors + 1))
          else
            print_message "info" "Validating CHANGELOG.md format"
            
            if ! grep -q "## \[Unreleased\]" docs/CHANGELOG.md; then
              print_message "error" "CHANGELOG.md missing [Unreleased] section"
              validation_errors=$((validation_errors + 1))
            fi
            
            if ! grep -q "### Added\|### Changed\|### Fixed\|### Removed" docs/CHANGELOG.md; then
              print_message "warning" "CHANGELOG.md could benefit from standard sections (Added, Changed, Fixed, Removed)"
            fi
            
            print_message "success" "CHANGELOG.md validation completed"
          fi
          
          # Enhanced README validation
          readme_found=false
          for readme in README.md docs/README.md; do
            if [ -f "$readme" ]; then
              print_message "info" "Found README at: $readme"
              readme_found=true
              
              # Check for essential sections
              if ! grep -qi "installation\|install" "$readme"; then
                print_message "warning" "$readme missing installation instructions"
              fi
              
              if ! grep -qi "usage\|example" "$readme"; then
                print_message "warning" "$readme missing usage examples"
              fi
              break
            fi
          done
          
          if [ "$readme_found" = false ]; then
            print_message "error" "No README.md found"
            validation_errors=$((validation_errors + 1))
          fi
          
          # Check for additional documentation files
          doc_files="CONTRIBUTING.md LICENSE SECURITY.md"
          for doc_file in $doc_files; do
            if [ -f "$doc_file" ] || [ -f "docs/$doc_file" ]; then
              print_message "success" "Found: $doc_file"
            else
              print_message "info" "Optional documentation missing: $doc_file"
            fi
          done
          
          if [ $validation_errors -gt 0 ]; then
            print_message "error" "Documentation validation failed with $validation_errors errors"
            exit 1
          else
            print_message "success" "All documentation validation checks passed"
          fi

      - name: ðŸ“Š Generate documentation summary
        if: always()
        run: |
          source .github/scripts/workflow_utils.sh
          step_duration=$(report_step_timing "Documentation Validation" "$STEP_START_TIME")
          
          if [ "${{ job.status }}" = "success" ]; then
            create_step_summary "Documentation Validation" "success" "| Validation | Complete |\n| Duration | ${step_duration}s |"
          else
            error_report=$(generate_error_report "Documentation Validation" "Documentation validation failed" "Missing or malformed documentation files" "- Add missing CHANGELOG.md in docs/\n- Ensure README.md exists\n- Follow standard documentation structure")
            echo "$error_report" >> $GITHUB_STEP_SUMMARY
            create_step_summary "Documentation Validation" "failure"
          fi

  # Final summary job
  ci-summary:
    name: ðŸ“‹ CI Summary
    if: always()
    needs: [test, lint, security, validate-docs]
    runs-on: ubuntu-latest
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ“¦ Load workflow utilities
        run: |
          chmod +x .github/scripts/workflow_utils.sh
          source .github/scripts/workflow_utils.sh

      - name: ðŸ“Š Generate comprehensive CI summary
        run: |
          source .github/scripts/workflow_utils.sh
          
          # Determine overall status
          overall_status="success"
          if [[ "${{ needs.test.result }}" != "success" ]] || [[ "${{ needs.lint.result }}" != "success" ]] || [[ "${{ needs.validate-docs.result }}" != "success" ]]; then
            overall_status="failure"
          fi
          
          # Security is allowed to fail, so only warn
          security_status="${{ needs.security.result }}"
          if [[ "$security_status" != "success" ]]; then
            print_message "warning" "Security scan completed with warnings (non-blocking)"
          fi
          
          # Create comprehensive summary
          {
            echo "# ðŸ”„ CI Pipeline Summary"
            echo ""
            echo "## Job Status"
            echo "| Job | Status | Duration |"
            echo "|-----|--------|----------|"
            echo "| ðŸ§ª Test Scripts | ${{ needs.test.result }} | - |"
            echo "| ðŸ” Lint & Code Quality | ${{ needs.lint.result }} | - |"
            echo "| ðŸ›¡ï¸ Security Scan | ${{ needs.security.result }} | - |"
            echo "| ðŸ“š Documentation | ${{ needs.validate-docs.result }} | - |"
            echo ""
            
            if [ "$overall_status" = "success" ]; then
              echo "âœ… **Overall Status:** All critical checks passed!"
            else
              echo "âŒ **Overall Status:** Some checks failed"
              echo ""
              echo "## Troubleshooting"
              echo "- Check individual job logs for detailed error information"
              echo "- Ensure all scripts pass syntax validation"
              echo "- Verify documentation structure follows project standards"
              echo "- Review linting errors and apply suggested fixes"
            fi
            
            echo ""
            echo "## Next Steps"
            if [ "$overall_status" = "success" ]; then
              echo "- âœ… Ready for merge/deployment"
              echo "- ðŸš€ All quality gates passed successfully"
            else
              echo "- ðŸ”§ Address failing checks before proceeding"
              echo "- ðŸ“ Review job-specific error reports above"
              echo "- ðŸ”„ Re-run workflow after fixes"
            fi
          } >> $GITHUB_STEP_SUMMARY
          
          print_message "$overall_status" "CI Pipeline completed with status: $overall_status"
